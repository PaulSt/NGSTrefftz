#include "constraint_trefftz.hpp"
#include <basematrix.hpp>
#include <bilinearform.hpp>
#include <core/array.hpp>
#include <core/flags.hpp>
#include <core/localheap.hpp>
#include <cstddef>
#include <elementtopology.hpp>
#include <expr.hpp>
#include <integrator.hpp>
#include <memory>
#include <pybind11/cast.h>
#include <integratorcf.hpp>

#include <fem.hpp>
#include <symbolicintegrator.hpp>
#include <fespace.hpp>

using namespace ngfem;

namespace ngcomp
{
  /// creates an embedding marix P for the given operation `op`.
  /// The embedding is subject to the constraints specified in
  /// `cop_lhs` and `cop_rhs`.
  ///
  ///  `op`: the differential operation
  ///
  ///  `fes`: the finite element space of `op`
  ///
  ///  `cop_lhs`: left hand side of the constraint operation
  ///
  ///  `cop_rhs`: right hand side of the constraint operation
  ///
  ///  `fes_constraint`: finite element space of the constraint operation
  ///
  ///  `trefftzndof`: number of degrees of freedom per element
  ///      in the Trefftz finite element space on `fes`, generated by `op`
  ///      (i.e. the local dimension of the kernel of `op` on one element)
  ///
  ///  `debug`: if `True`, print debug messages. Default: `False`
  ///
  ///  returns: P
  template <class SCLA>
  std::shared_ptr<ngbla::Matrix<SCLA>>
  ConstraintTrefftzEmbedding (std::shared_ptr<ngfem::SumOfIntegrals> op,
                              std::shared_ptr<FESpace> fes,
                              std::shared_ptr<ngfem::SumOfIntegrals> cop_lhs,
                              std::shared_ptr<ngfem::SumOfIntegrals> cop_rhs,
                              std::shared_ptr<FESpace> fes_constraint,
                              int trefftzndof)
  {
    // #TODO what is a good size for the local heap??
    LocalHeap local_heap = LocalHeap (1000 * 1000 * 1000);
    auto mesh_access = fes->GetMeshAccess ();
    size_t ne = mesh_access->GetNE (VOL);
    size_t ndof = fes->GetNDof ();
    size_t dim = fes->GetDimension ();

    // let L be the matrix corrensponding to
    // the differential operator op
    T_BilinearForm<SCLA> opbf
        = T_BilinearForm<SCLA> (fes, "Base FE Space", Flags ({}));

    // #TODO is there an easier way to add the whole
    // SumOfIntegrals at once?
    // ~~~~
    // iterate over each integral individually,
    // instead of the python way where one can add the whole sum at once
    for (auto integral : *op)
      {
        opbf.AddIntegrator (integral->MakeBilinearFormIntegrator ());
      }

    opbf.Assemble (local_heap);
    const BaseMatrix &L = opbf.GetMatrix ();

    // let B1 be the matrix corrensponding to
    // the left hand side constraint operator cop_lhs
    T_BilinearForm<SCLA> copbf_lhs = T_BilinearForm<SCLA> (
        fes, fes_constraint, "Mixed FE Space", Flags ({}));

    for (auto integral : *cop_lhs)
      {
        copbf_lhs.AddIntegrator (integral->MakeBilinearFormIntegrator ());
      }

    copbf_lhs.Assemble (local_heap);
    const BaseMatrix &B1 = copbf_lhs.GetMatrix ();

    // let B2 be the matrix corrensponding to
    // the right hand side constraint operator cop_rhs
    T_BilinearForm<SCLA> copbf_rhs = T_BilinearForm<SCLA> (
        fes_constraint, "Constraint FE Space", Flags ({}));

    for (auto integral : *cop_rhs)
      {
        copbf_rhs.AddIntegrator (integral->MakeBilinearFormIntegrator ());
      }

    copbf_rhs.Assemble (local_heap);
    const BaseMatrix &B2 = copbf_lhs.GetMatrix ();

    // number of degrees of freedom of the contraint finite element space
    const size_t n_constr = fes_constraint->GetNDof ();

    // layout:
    // /    |    \
    // | P1 | P2 |
    // \    |    /
    // with P1 having shape (fes.ndof, n_constr),
    Matrix<SCLA> P = Matrix<SCLA> (fes->GetNDof (), n_constr);
    P = 0.0;

    // solve the following linear system in an element-wise fashion:
    // L @ T1 = B for the unknown matrix T1,
    // with the given matrices:
    //     /   \    /   \
    //  A= |B_1| B= |B_2|
    //     | L |    | 0 |
    //     \   /    \   /
    mesh_access->IterateElements (
        VOL, local_heap,
        [&] (Ngs_Element mesh_element, LocalHeap &local_heap) {
          const ElementId el_id = ElementId (mesh_element);
          const FiniteElement &fes_element = fes->GetFE (el_id, local_heap);

          // #TODO: does array construction wor this way?
          Array<DofId> dofs = Array<DofId> ();
          fes->GetDofNrs (el_id, dofs);

          Array<DofId> dofs_constraint = Array<DofId> ();
          fes_constraint->GetDofNrs (el_id, dofs_constraint);
        });

    return make_shared<Matrix<SCLA>> (P);
  }
}

void ExportConstraintTrefftzEmbedding (py::module m)
{
  m.def ("ConstraintTrefftzEmbedding",
         &ngcomp::ConstraintTrefftzEmbedding<double>,
         "creates the constraint Trefftz embedding matrix", py::arg ("op"),
         py::arg ("fes"), py::arg ("cop_lhs"), py::arg ("cop_rhs"),
         py::arg ("fes_constraint"), py::arg ("trefftzndof"));
}
