#ifndef FILE_SVDTREFFTZ_HPP
#define FILE_SVDTREFFTZ_HPP
#include <comp.hpp>
#include <python_comp.hpp>
#include <fem.hpp>
#include <integratorcf.hpp>
#include <bla.hpp>

namespace ngcomp
{

  template <typename SCAL>
  std::tuple<vector<shared_ptr<Matrix<SCAL>>>, shared_ptr<BaseVector>>
  EmbTrefftz (shared_ptr<SumOfIntegrals> bf, shared_ptr<FESpace> fes,
              shared_ptr<SumOfIntegrals> lf, double eps,
              shared_ptr<FESpace> test_fes, int tndof, bool getrange,
              std::map<std::string, Vector<SCAL>> *stats = nullptr);

  /// creates an embedding marix P for the given operations `op`,
  /// `cop_lhs`, `cop_rhs`.
  ///
  /// The embedding is subject to the constraints specified in
  /// `cop_lhs` and `cop_rhs`.
  ///
  ///  @param op the differential operation
  ///
  ///  @param fes the finite element space of `op`
  ///
  ///  @param cop_lhs left hand side of the constraint operation
  ///
  ///  @param cop_rhs right hand side of the constraint operation
  ///
  ///  @param fes_constraint finite element space of the constraint operation
  ///
  ///  @param ndof_trefftz number of degrees of freedom per element
  ///      in the Trefftz finite element space on `fes`, generated by `op`
  ///      (i.e. the local dimension of the kernel of `op` on one element)
  ///
  ///  @return (P, f), the embedding `P` and particlar solution `f`. `P` is
  ///  represented as a vector of all element matrices.
  template <typename SCAL>
  tuple<vector<shared_ptr<Matrix<SCAL>>>, shared_ptr<ngla::BaseVector>>
  EmbTrefftz (const SumOfIntegrals &op, const FESpace &fes,
              const ngfem::SumOfIntegrals &cop_lhs,
              const ngfem::SumOfIntegrals &cop_rhs,
              const FESpace &fes_constraint,
              shared_ptr<const ngfem::SumOfIntegrals> linear_form,
              const size_t ndof_trefftz);

  template <typename T, typename shrdT>
  class EmbTrefftzFESpace
      : public T //, public std::enable_shared_from_this<EmbTrefftzFESpace>
  {
    vector<shared_ptr<Matrix<double>>> ETmats;
    vector<shared_ptr<Matrix<Complex>>> ETmatsC;
    shrdT fes;
    Array<DofId> all2comp;

  public:
    EmbTrefftzFESpace (shared_ptr<MeshAccess> ama, const Flags &flags,
                       bool parseflags = false)
        : T (ama, flags, parseflags)
    {
      throw Exception ("Please provide a base fes for the embedding");
    }

    EmbTrefftzFESpace (shrdT afes)
        : T (afes->GetMeshAccess (), afes->GetFlags (), false), fes (afes)
    {
      this->name = "EmbTrefftzFESpace";
      this->type = "embt";
      this->needs_transform_vec = true;
      this->iscomplex = afes->IsComplex ();
      shared_ptr<CompoundFESpace> cafes
          = dynamic_pointer_cast<CompoundFESpace> (afes);
      if (cafes)
        for (auto space : cafes->Spaces ())
          dynamic_cast<CompoundFESpace *> (this)->AddSpace (space);
      // this->Update();
      // this->UpdateDofTables();
      // this->UpdateCouplingDofArray();
      // this->FinalizeUpdate();
    }

    shared_ptr<BaseVector>
    SetOp (shared_ptr<SumOfIntegrals> bf, shared_ptr<SumOfIntegrals> lf,
           double eps, shared_ptr<FESpace> test_fes, int tndof);

    void GetDofNrs (ElementId ei, Array<int> &dnums) const override;

    virtual void VTransformMR (ElementId ei, const SliceMatrix<double> mat,
                               TRANSFORM_TYPE type) const override;

    virtual void VTransformMC (ElementId ei, const SliceMatrix<Complex> mat,
                               TRANSFORM_TYPE type) const override;

    virtual void VTransformVR (ElementId ei, const SliceVector<double> vec,
                               TRANSFORM_TYPE type) const override;

    virtual void VTransformVC (ElementId ei, const SliceVector<Complex> vec,
                               TRANSFORM_TYPE type) const override;

    shared_ptr<GridFunction> Embed (shared_ptr<GridFunction> tgfu);

    shared_ptr<BaseMatrix> GetEmbedding ();
  };
}

#ifdef NGS_PYTHON
#include <python_ngstd.hpp>
void ExportEmbTrefftz (py::module m);
#endif // NGS_PYTHON

#endif
